library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
library(FactoMineR)
library(readxl)
library(readr)
# # df <- USArrests[,1:2]
# df_birds <- read_xlsx("data/short.xlsx", col_types = c("text","numeric","numeric"))
# df <- na.omit(df_birds)
# df <- scale(df[,2:3])
# head(df)
european_birds <- read_delim("data/european_birds.txt",
delim = "\t", escape_double = FALSE,
trim_ws = TRUE)
european_birds %>%
dplyr::select(Species,
LengthU_MEAN,
# WingU_MEAN,
Clutch_MEAN,
`Life span`) -> df_birds
df_birds <- na.omit(df_birds)
df <- scale(df_birds[,2:dim(df_birds)[2]])
head(df)
distance <- get_dist(df)
fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
fviz_nbclust(df, kmeans, method = "wss")
fviz_nbclust(df, kmeans, method = "silhouette")
gap_stat <- clusGap(df, FUN = kmeans, nstart = 25,
K.max = 10, B = 50)
fviz_gap_stat(gap_stat)
# Compute k-means clustering with k = 4
set.seed(123)
final <- kmeans(df, 3, nstart = 25)
print(final)
fviz_cluster(final, data = df,
geom = c("point"),
ellipse.type = "euclid")
final$cluster
df_birds %>%
mutate(cluster_id = final$cluster) -> df_birds_cluster
write.csv(df_birds_cluster, file = "output/df_birds_cluster.csv")
writexl::write_xlsx(df_birds_cluster, "output/df_birds_cluster.xlsx")
head(df_birds_cluster)
df_birds_cluster %>%
group_by(cluster_id) %>%
summarise(meanLength = mean(LengthU_MEAN),
meanWing = mean(WingU_MEAN),
meanLifeSpan = mean(`Life span`),
meanClutch = mean(Clutch_MEAN))
df_birds_cluster %>%
group_by(cluster_id) %>%
summarise(meanLength = mean(LengthU_MEAN),
# meanWing = mean(WingU_MEAN),
meanLifeSpan = mean(`Life span`),
meanClutch = mean(Clutch_MEAN))
data(PbHeron)
# without group specified
binaryMDS(PbHeron[,4:15])
library(NADA2)
install.packages("NADA2")
esempio1 <- read.csv("data/esempio1.csv")
esempio1
esempio1 <- read.csv("data/esempio1.csv", sep = ";")
esempio1
es
mean(esempio1$Weight, na.rm = TRUE)
mean(esempio1$Weight, na.rm = TRUE)
# using the read.csv function
y <- read.csv("data/captures.csv",sep=";")
class(y) # this is a data frame
head(y) # we can see the first rows of our data frame
# or from an excel file:
# we need a specific package in this case, and we need to install it:
# install.packages("xlsx") # the line is commented because you just need to run it once
library(xlsx)
# read in the worksheet named mysheet
mydata <- read.xlsx("data/database_esercizio.xls", sheetName = "captures")
class(mydata)
install.packages("xlsx")
# or from an excel file:
# we need a specific package in this case, and we need to install it:
# install.packages("xlsx") # the line is commented because you just need to run it once
library(xlsx)
# read in the worksheet named mysheet
mydata <- read.xlsx("data/database_esercizio.xls", sheetName = "captures")
# using the read.csv function
y <- read.csv("data/captures.csv",sep=";")
class(y) # this is a data frame
head(y) # we can see the first rows of our data frame
## ---- Extract a column (i.e. a variable) -----
# we can do this using '$'
y$weight_g
# or subsetting the data frame, using square brackets '[ ]'
y["weight_g"]
y[,10] # the weight of the animals is stored in the 10th column
y[1,10] # the weight of the animals is stored in the 10th column
y[23,10] # the weight of the animals is stored in the 10th column
y[,10] # the weight of the animals is stored in the 10th column
# Let's ask R what kind of variable we are dealing with, using the 'class' function again
class(y$weight_g)
w <- y$weight_g
w
?hist # this is the simplest way to get help in R! just a question mark!
?hist # this is the simplest way to get help in R! just a question mark!
hist(y$weight_g, main="", xlab="Animal weight (g)") # with default break
hist(y$weight_g, breaks=30, main="", xlab="Animal weigth (g)") # we specified a single number giving
# dotplots (or stripcharts)
# op <- par(mfrow=c(1,3))
?stripchart
stripchart(y$weight_g, xlab="Animal weigth (g)")
stripchart(y$weight_g, xlab="Animal weigth (g)", method="jitter")
stripchart(y$weight_g, xlab="Animal weigth (g)", method="stack")
# boxplot
boxplot(y$weight_g, ylab="Animal weigth (g)")
boxplot(y$weight_g ~ y$sex + y$age, ylab="Animal weigth (g)")
boxplot(y$weight_g ~ y$sex, ylab="Animal weigth (g)")
# exercise (by your own): do the same with the foot lenght
boxplot(y$footlength_mm, ylab="Foot length (mm)")
# using the read.csv function
y <- read.csv("data/captures.csv",sep=";")
class(y) # this is a data frame
head(y) # we can see the first rows of our data frame
t
## ---- Extract a column (i.e. a variable) -----
# we can do this using '$'
y$weight_g
# boxplot
boxplot(y$weight_g, ylab="Animal weigth (g)")
## the mean and the median
weight <- na.omit(y$weight_g)
mean(y$weight_g)
## ---- Extract a column (i.e. a variable) -----
# we can do this using '$'
y$weight_g
## the mean and the median
weight <- na.omit(y$weight_g)
weight
# mean
mean(weight)
mean(y$weight_g)
# median
median(weight)
hist(weight,prob=T,ylim=c(0,0.05)) # prob=T for relative frequencies (density)
hist(weight,prob=T,ylim=c(0,0.05)) # prob=T for relative frequencies (density)
lines(density(rnorm(1000000,mean(weight),sd(weight))),col="red")
segments(mean(weight),0,mean(weight),0.047,col="blue")
segments(median(weight),0,median(weight),0.047,col="green")
## the mode
# R does not have a standard in-built function to calculate mode.
# So we create a user function to calculate mode of a data set in R.
# This function takes the vector as input and gives the mode value as output.
# Create the function.
getmode <- function(x) {
uniqv <- unique(x)
uniqv[which.max(tabulate(match(x, uniqv)))]
}
getmode(weight)
## range
range(weight)
## quantile
quantile(weight) # in R, quartiles are the default for the quantile function
median(weight)
?boxplot # check the range argument and its default value
boxplot(weight, range=0)
boxplot(na.omit(y$footlength_mm))
boxplot(na.omit(y$footlength_mm), range=0)
# summary
summary(weight)
## variance
var(weight)
## standard deviation
sd(weight)
## standard error
sd(weight)/sqrt(length(weight))
sd(weight)/sqrt(119)
# boxplot
op <- par(mfrow=c(1,2))
boxplot(y$footlength_mm, col = "lightgray", ylim=c(10,30))
# boxplot(log(y$footlength_mm), col = "lightgray")
mtext("80", line=-1)
points(x=29)
# Cleveland plot/dotchart
dotchart(y$footlength_mm)
par(op)
par(mfrow=c(1,1))
# identify the outlier
plot(x=y$footlength_mm, y=y$capture_id)
identify(x=y$footlength_mm, y=y$capture_id)
# press Esc to stop the identify stuff
y[102,]
y$weight_g
(y$weight_g)[y$weight_g > 30] #seleziona sotto insieme, quadre sono selezione, ma possono avere un comando
y[,1] # one column (the first one)
# selecting subsets of data, according to their position or name
y[1,] # one row (the first one)
y[1:10,] # first ten rows
y[5:10,] # from 5th to 10th row
y["29",] # by row name, useful if we removed some rows from the dataset
y[c("29","45"),] # by row name, more than a row
y[,5:10] # from 5th to 10th column
y[,c("chip","trap_id")] # by column name, more than a column
y[1:5,c("chip","trap_id")] #combines reading columns and rows
# selecting subsets of data, according to their values
library(dplyr)
install.packages("dplyr")
# selecting subsets of data, according to their values
library(dplyr)
library(tidyverse) #this has a lot more stuff than what we mainly need
install.packages("tidyverse")
library(tidyverse) #this has a lot more stuff than what we mainly need
# selecting subsets of data, according to their values
library(dplyr)
filter(y, trap_id > 43) #select in your rows BUt by value and not position
# or
y %>% filter(trap_id > 43)
filter(y, trap_id > 43 & occasion < 20)
filter(y, trap_id < 5 | trap_id > 65) #add criteria to same column
arrange(y, trap_id)
select(y, chip, trap_id)
y %>%
select(chip, trap_id) %>% #gotta repeat pipe %>% to tell R to keep it up
filter(trap_id > 65) %>%
arrange(trap_id)
# summarizing data within groups
names(y)
y$age
y %>% group_by(age)
y %>% group_by(age) %>% summarise(mean.w = mean(na.omit(weight_g)))
summarise(mean.w = mean(na.omit(weight_g)))
y$sex
y %>% group_by(age, sex) %>% summarise(mean.w = mean(na.omit(weight_g)))
gc()
sample(x = 1:6, size = 5, replace = FALSE)
sample(x = 1:6, size = 20, replace = TRUE)
d1 <- RollDie(n = 50)
RollDie <- function(n) sample(1:6, n, replace = TRUE) #makes rolldie a function
d1 <- RollDie(n = 50)
sum(d1 == 6)
sum(d1 == 6)/50
d1 <- RollDie(n = 50)
hist(d1)
hist(d1, probability = TRUE, breaks = seq(0.5,6.5,1))
sims <- vector("list", 500)
probs <- vector("numeric", 500)
for (n in 1:500) {
sims[[n]] <- RollDie(n)
probs[n] <- sum(sims[[n]] == 6)/n
}
plot(probs)
abline(h=1/6)
plot(probs)
abline(h=1/6)
abline(h=1/6,)
abline(h=1/6,a=NULL,b=NULL,v=NULL,reg=NULL,coef=NULL,untf=FALSE)
plot(probs)
y <- read.csv("data/captures.csv",sep=";")
y <- na.omit(y[,c("age", "sex")])
y <- read.csv("data/captures.csv",sep=";")
y <- na.omit(y[,c("age", "sex")])
library(dplyr)
y %>%
group_by(age) %>%
summarise(n = n()) %>% #n() just counts the events (in this case it counts the amounts f captures)
y %>%
group_by(age) %>%
summarise(n = n())
y %>%
group_by(age) %>%
summarise(n = n()) %>% #n() just counts the events (in this case it counts the amounts f captures)
y %>%
group_by(age) %>%
summarise(n = n()) %>%
age.marginal.df <-
y %>%
group_by(age) %>%
summarise(n = n()) %>%
age.marginal.df <-
y %>%
group_by(age) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
y %>%
group_by(age) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
age.marginal.df <-
y %>%
group_by(age) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
age.marginal.df
y %>%
group_by(sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
sex.marginal.df <-
y %>%
group_by(sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
sex.marginal.df
joint.df <-
y %>%
group_by(age, sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
joint.df
sex.marginal.df <-
y %>%
group_by(sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
joint.df <-
y %>%
group_by(age, sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
joint.df <-
y %>%
group_by(age, sex) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(prop = n/sum(n))
joint.df
joint.prob <-
joint.df %>%
filter(age == "A", sex == "F") %>%
.$prop
joint.prob
marg.prob <-
age.marginal.df %>%
filter(age == "A") %>%
.$prop
marg.prob
cond.prob <- joint.prob/marg.prob
cond.prob
# Read captures.csv (name it 'captures')
captures<-read.csv("data/captures.csv")
class("captures")
class(captures)
dim(captures)
# Check the dimensions of captures
?dim()
captures
# Read captures.csv (name it 'captures')
captures<-read.csv("data/captures.csv")
class(captures)
dim(captures)
captures
# Read captures.csv (name it 'captures')
captures<-read.csv("data/captures.csv",sep=";")
captures
y
captures
dim(captures)
class(captures)
# View the column names of captures
?names()
name(captures)
names(captures)
# Check the structure of captures
str(captures)
# View a summary of captures
summary(captures)
# Print captures to the console
captures
# View the first 6 rows
head(captures)
# View the first 15 rows
head(captures,15)
# View the last 6 rows
tail(captures)
# View the last 10 rows
tail(captures,10)
# Produce an histogram of weight
hist(captures$weight_g)
# Plot the capture ID no. towards the DOY
plot(x=captures$DOY, y=captures$capture_id)
# install.packages("dplyr") # run this line only if the package is not yet installed
library(dplyr) # load the package
library(tidyverse)
# install.packages("dplyr") # run this line only if the package is not yet installed
library(dplyr) # load the package
# Transform the weight of the animals using the function log
log(captures$weight_g)
# Divide weight by the foot length and save the new variable as wfratio
wfratio <- captures$weight_g/captures$footlength_mm
# add the column wfratio to the captures data frame, creating a new data frame called captures.new
captures.new <- cbind(captures, wfratio) # using R base function `cbind`
?cbind
captures %>%
mutate(wfratio = weight_g/footlength_mm) -> captures.new
head(captures.new)
# remove the data frame captures.new from the working environment
rm(captures.new)
# now add both the log of the weight and the column wfratio to the captures data frame, creating again new data frame called captures.new
captures %>%
mutate(logw = log(weight_g),
wfratio = weight_g/footlength_mm) -> captures.new
head(captures.new)
# DO IT ON YOUR OWN - ADD ANOTHER VARIABLE TO THE DATA FRAME, E.G. YEAR + 1
captures %>%
mutate(wrongyear=year+1)->captures.new
head(captures.new)
rm(captures.new)
# filter data selecting only weights < 25
filter(captures, weight_g == 25)
# filter data selecting only weights < 25
filter(captures, weight_g < 25)
# filter data selecting only weights < 25
filter(captures, weight_g == 25)
# filter data selecting only weights < 25, but not... really, it gives me weight = to 25
filter(captures, weight_g = 25)
# filter data selecting only weights < 25, but not... really, it gives me weight = to 25
filter(captures, weight_g == 25)
# filter data selecting only weights < 25
filter(captures, weight_g< 25)
# filter data selecting only weights < 25 or > 40
filter(captures, weight_g < 25 | weight_g > 40)
# filter data selecting only weights > 40 and foot length > 18
filter(captures, footlength_mm > 18 & weight_g > 40)
# filter data selecting only weights < 25
filter(captures$weight_g<25)
# filter data selecting only weights < 25
filter(captures, weight_g<25)
# filter data selecting only weights < 25 or > 40
filter(captures, weight_g<25 | weight_g>40)
# filter data selecting only weights > 40 and foot length > 18
filter(captures, weight_g>40 & footlenght_mm>18)
# filter data selecting only weights > 40 and foot length > 18
filter(captures, weight_g>40 & footlength_mm>18)
# DO IT ON YOUR OWN - SELECT ONLY CAPTURES RECORDED AFTER DOY 210
filter(captures, DOY>210)
# SELECT ONLY CAPTURES RECORDED IN JULY
filter(captures, month==7)
# select columns by name
captures %>%
select(weight_g, sex, age, footlength_mm)
# select all columns between weight and age
captures %>%
select(weight_g:age)
# select all columns except dawn
captures %>%
select(-(dawn))
# select all columns except those from animal_id to furmark
captures %>%
select(-(animal_id:furmark))
# select columns from weight_g to footlenght_mm, excluding reproductive status
captures %>%
select(weight_g:footlength_mm) %>%
select(-repr_status)
captures %>%
group_by(sex) %>%
summarise(mean(weight_g, na.rm=TRUE))
summarise(mean.w = (mean(na.omit(weight_g)))
# DO IT ON YOUR OWN - CALCULATE THE MEAN TAKING INTO ACCOUNT THE AGE CLASS
# DO IT ON YOUR OWN - CALCULATE THE MEAN TAKING INTO ACCOUNT THE AGE CLASS
captures %>%
# DO IT ON YOUR OWN - CALCULATE THE MEAN TAKING INTO ACCOUNT THE AGE CLASS
captures %>%
group_by(age) %>%
summarise(mean.w = (mean(na.omit(weight_g))))
captures %>%
group_by(age, sex) %>%
summarise(mean(weight_g, na.rm=TRUE))
captures %>%
group_by(age, sex) %>%
summarise(mw = mean(weight_g, na.rm=TRUE), mf = mean(footlength_mm, na.rm=TRUE))
# or:
captures %>%
group_by(sex) %>%
summarise(mean(weight_g, na.rm=TRUE)) %>%
ungroup()
# sort the weigth of the animals
sort(captures$weight_g)
sort(captures$weight_g, decreasing = TRUE)
captures %>%
arrange(weight_g)
captures %>%
arrange(desc(weight_g))
# DO IT ON YOUR OWN - ARRANGE THE DATA FRAME ACCORDING TO FOOT LEGTH, BOTH IN ASCENDING AND DESCENDING ORDER
captures %>%
arrange(footlength_mm)
# DO IT ON YOUR OWN - ARRANGE THE DATA FRAME ACCORDING TO FOOT LEGTH, BOTH IN ASCENDING AND DESCENDING ORDER
captures %>%
arrange(desc(footlength_mm))
# DO IT ON YOUR OWN
?arrange
captures %>%
group_by(age)
# DO IT ON YOUR OWN
?arrange
captures %>%
group_by(age) %>%
arreange(weigth_g, .by_group =TRUE)
captures %>%
group_by(age) %>%
arrange(weigth_g, .by_group =TRUE)
captures %>%
group_by(age) %>%
arrange(weight_g, .by_group =TRUE)
# order according to weight and then to footlenght
captures %>%
arrange(desc(weight_g), footlength_mm)
